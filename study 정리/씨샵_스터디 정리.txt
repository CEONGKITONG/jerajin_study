1. C# 교과서 마스터하기 01. C# 교과서 책 마스터하기 시작, C# 강의, C# 강좌, C# 동영상 강의
2. C# 강의 - C# 교과서 마스터하기 02. 준비사항
	- windwos 10
	- visual studio 2019 설치 (https://my.visualstudio.com/Downloads?q=visual%20studio%202019&wt.mc_id=o~msft~vscom~older-downloads)
	- .Net Core 3.1 SDK 설치  (https://dotnet.microsoft.com/en-us/download)
	- .Net SDK 를 가지고 빌드
	
	
	- .Net Core SDK 설치
		start https://dot.net
	- visual stuido code 설치
		start https://code.visualstudio.com
	- visual studio community 설치
		start https://www.visualstudio.com
		
	- Microsoft Store 에서 Windows Terminal 설치
		=> 화면 탭 사용 가능
	
	- dotnet new -l
		console 형 dotnet 프로젝트 생성 옵션 조회
	- dotnet new console -o HellowWorldConsole
		console 기반으로 HellowWorldConsole 프로젝트 생성
	- console 모드에서 F7 키 : 직전 사용한 console 명령 조회
	- dotnet run
		현재 디랙토리의 프로젝트를 빌드해서 실행
	- code . 
		현재 프로젝트를 VisualStudio Code로 Open 하여 편집해라
		
	- ctrl + ee  key : 특정 코드를 테스트하고 싶을때 사용 (C# Interactive) (c# 대화형)
	
3. C# 강의 - C# 교과서 마스터하기 03. Hello, World
	- https://try.dot.net/
		=> 웹에서 c# 코드를 테스트할 수 있는 사이트
	- 코드 조각
		cw + tab + tab 누르면 Console.WriteLine(); 코드 가 자동 입력된다.
	- c#9.0 부터는 class 와 main 메서드가 없어도 코드가 실행 될 수 있다.
	- dotnet new console
		=> 현재 디렉토리 이름으로 console 프로젝트 생성하는 명령
	- Visual Studio Code 에서 View -> Terminal 에서 콘솔 명령으로 입력 가능
	- Linux (ubuntu) 에서 사용 가능
		Visual Studio Code 로 개발가능
		Windows Form와 WPF 는 Windwos 환경에서만 사용 가능
	- https://learn.microsoft.com/ko-kr/dotnet/csharp/
	- 마이크로 소프트 언어 포털
		https://www.microsoft.com/ko-kr/language/Search?&searchTerm=method&langID=457&Source=true&productid=0
		=> 해당 언어를 공식 사용
	- 닷넷 api 브라우저
		https://learn.microsoft.com/en-us/dotnet/api/
		
		
		
40. 대리자 (Delegate)
	- delegate void Runner();
	  static void RunnerCall(Runner runner) => runner();  // 넘어온 메서드 실행 (runner 가 어떤 메서드 이던간에 파라미터 형식과 리턴 형식만 맞으면 넘긴 메서드를 그대로 실행한다.)
	  
	- Action 대리자: 반환값이 없는 메서드를 대신 호출합니다
	- Func 대리자: 매개변수와 반환값이 있는 메서드를 대신 호출합니다
		Func<매개변수형식, 반환값형식>
		Func<매개변수형식, 매개변수형식,.. ,반환값형식>
	- Predicate 대리자: T 매개변수에 대한 bool 값을 반환하는 메서드를 대신 호출합니다
	
	- Func<int> getNumber1 = delegate () { return 1234; };   => 무명 메서드()
	  Func<int> getNumber2 = () => 1234;   => 람다식
	
	- Func<int, int> anonymous = delegate (int x) { return x * x; }; //① 익명 메서드 담기
	  Func<int, double> lambda = x => x / (double)2;                 //② 람다 식 담기
	  => 익명 메서드 대신 람다식을 많이 사용한다.
	  
	  
	- static void StringLengthPrint(Func<string, int> stringlength, string message)
	  => 첫번째 파라미터에 int 형을 리턴하는 함수를 넘기기 가능
		Func<string, int> stringlength = data.Length;  와 같은 표현
	  => String 으로 파라미터를 받고, int 형으로 return 하는 함수를 파라미터로 넘겨라.
	  = > stringlength 은 int StringLength(string data) 함수의 alias 같은 것
		
		
		
	- static void Main() => StringLengthPrint(StringLength, "안녕하세요.");
		=> 결국 StringLengthPrint (int, string) 형태
		
	- 함수형 프로그래밍 (https://mangkyu.tistory.com/111)
		데이터를 변환하는 함수의 조합으로 구성되는 프로그램 작성 방법. 함수의 출력은 입력에 의해서만 정해지고, 함수를 실행하는 명령어를 내포한 구조로 연결하여 프로그램을 작성한다. (네이버)
		함수형 프로그램은 기본적으로 람다형 문법을 따르는 방식 (https://blog.naver.com/sr_it_/222435285856)
		함수 파라미터에 함수를 넘기는 방식
		객체의 빌더 패턴과 유사
			필요한 함수들을 조합해서 사용
			String result = words.stream()
                .filter(w -> w.length() > 1)
                .map(String::toUpperCase)
                .map(w -> w.substring(0, 1))
                .collect(Collectors.joining(" "));
		C#에서 함수형 프로그램밍의 정점은 LINQ
			=> 특정 데이터를 결과를 다음 함수에 넘겨 연결해서 처리할 수 있다. (메서드 체이닝)(파이프라인 개념과 유사)
			
			
41. 이벤트
	- 1. Delegate 선언 (이벤트 핸들러)
	  2. Delegate 로 된 event 선언
	  3. event에 이벤트 핸들러 메서드 할당
	  4. 이벤트 발생
	  
46. 특성과 리플렉션
	- 닷넷 내장 특성
		Conditional : 특정 기호 선언여부일 경우 실행되고
			[Conditional("DEBUG")]		: 디버그 모드 인경우 실행하는 메서드
			[Conditional("RELEASE")]	: 릴리즈 모드 인경우 실행하는 메서드
		CallerMemberName : 호출한 멤버 이름 	
		CallerFilePath : 호출한 파일 경로
		CallerLineNumber : 호출한 소스 라인 번호
	- 사용자 지정 특성
		Attribute 클래스 상속해서 생성 가능
	- 클래스에 적용되어 있는 특성 목록 조회 하기
		Attribute[] attrs = Attribute.GetCustomAttributes(typeof(NickNameAttributeTest));
	- 리플렉션
		- 
            MemberClass m = new MemberClass();
            Type t = m.GetType();
            
            PropertyInfo pi = t.GetProperty("Name");			// 객체가 가진 특정  프로퍼티 객체 가져옴

            Console.WriteLine("속성 호출 : {0} ", pi.GetValue(m));

            MethodInfo mi = t.GetMethod("GetName");				// 객체가 가진 특정 method 가져옴

            Console.WriteLine("메서드 호출 : {0}", mi.Invoke(m, null));		// 가져온 method 를 실행

            dynamic d = new MemberClass();

            Console.WriteLine("속성 호출 : {0}", d.Name);

            Console.WriteLine("메서드 호출 : {0}", d.GetName());
		- 문자열로 지정된 클래스로 객체 생성하기 (Type과 Activator 클래스 이용)
			
			Type type = Type.GetType("TypeAndActivator.MyClass");
			dynamic objType = Activator.CreateInstance(type);
			objType.Test();
			
			
49. 확장 메서드
	- 원본 메서드를 변경하지 않고 기능을 추가할 수 있는 기능
	- 봉인(sealed) 클래스는 상속이 불가능하므로, 봉인 클래스에 있는 메서드 원래 기능을 변경없이 기능을 추가할 수 있다.
	- static 클래스에 static 메서드로 구현해야한다.
	- 확장 메서드의 첫 번째 매개변수에 this 키워드를 지정하여 확장 메서드를 사용할 개체 형식을 선택
	
	
51. 튜플
	- 메서드에 여러개의 매개 변수를 전달할때 사용자 정의 클래스로 넘길 수 있지만, 사용자 정의 클래스를 정의하지 않고 여러개의 값을 넘기도록 할 수 있는 기능 (c#7.0 부터 지원)
	- 튜플 리터럴 : 하나 이상 값을 설정하는 방식
		특별한 아이템 명을 지정하지 않으면 설정한 값만큼 Item1, Item2, ... 로 참조한다
		var fhd = (1920, 1080);
		fhd.Item1
		fhd.Item2
		
		사용할 아이템명 지정 가능
		var fhd = (Width:1920, Height:1080);
		fhd.Width
		fhd.Height
		
		이름과 형식을 지정가능
		(ushort Width, ushort Height) hd = (1920, 1080)
		fhd.Width
		fhd.Height
		
	- 튜플 리턴 
		(아이템1, 아이템2) 함수 ()
		{
			var r = (12,3);
			return r;
		}
	  
52. 클래스 라이브러리와 닷넷 스탠다드
	- 닷넷을 사용하는 모든 영역에서 공통으로 사용할 수 있는 API (특별한 경우가 아니면 닷넷 스탠다드로 라이브러리 개발)
	
53. 테스트
	- MSTest /NUnit / xUnit
	- TestClass 특성 : Test 대상 Class
	- TestMethod 특성 : Test 대상 Method 라는 의미
			
54. NuGet 패키지
	- 닷넷  패키지 관리자
	- 라이브러리를 전 세계 개발자와 공유하기 위한 기능 (Add-On 추가 기능 같은..?)
	- NuGet 패키지 생성 : 프로젝트 속성 -> 패키지 -> 빌드시 NuGet 패키지 생성  옵션 체크하여 빌드 (*.nupkg 파일 생성됨)
	- NuGet 에 게시 : nuget.org 사이트 
	- NuGet 에서 라이브러리 가져오기 : 프로젝트 -> 종속성 -> nuGet 패키지에서 가져오기 패키지에 추가해서빌드해야 DLL이 다운로드된다.
	
	
	
[ C# WPF ] 	

1. C#, WPF HelloWorld(XAML기반)_WPF교육추천(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육)
	- XAML 기반 MAIN START XAML 은 APP.XAML 에서 아래 설정으로 정의한다.
	StartupUri="MainWindow.xaml"> 
	
2. (닷넷C#, WPF기초강좌)C#코드 기반의 HelloWorld_WPF실무교육/자마린실무교육학원
	- 코드 기반 MAIN START XAML 은 CLASS 파일에서 STATREAD 의 MAIN 메서드를 정의하여 실행할 CLASS를 정의한다.
	        public static void Main(string[] args)
        {            
            [STAThread]
            MainWindow app = new MainWindow();
            app.Run();
        }
		
		=> C# 9.0 버전
		    var thread = new Thread(() =>
            {
                MainWindow app = new MainWindow();
                app.Run();
            });
            thread.SetApartmentState(ApartmentState.STA);
            thread.Start();
	- // C# 9 에서는 STAThread 특성 지원 안함 (참조 : https://www.sysnet.pe.kr/Default.aspx?mode=2&sub=0&pageno=8&detail=1&wid=12623_)

http://ojc.asia/bbs/board.php?bo_table=WPF&wr_id=3&sfl=wr_subject&stx=WPF%EA%B8%B0%EC%B4%88&sop=and


3. WPF 데이터바인딩 심플예제, 데이터 바인딩이용하여 오라클테이블 데이터를 ListView에 출력(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육/C#강좌)
	- ODP.NET 을 이용하여 오라클 DB 접속 (ODP.NET 을 사용하기 위해서는 Oracle Developer Tool for Visual Studio 를 설치해야한다) NuGet으로 설치가능하며, 사이트에서 다운로드 받아 설치도 가능
		https://www.oracle.com/database/technologies/net-downloads.html
		
		
4. (WPF추천 동영상교육)C# 코드기반 WPF HelloWorld(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육/C#강좌)
	- WPF는 싱글 스레드로 동작해야한다.
5. (WPF쓰레드강좌)WPF 멀티쓰레드 프로그래밍_WPF멀티스레드,백그라운드워커,BackgroundWorker(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육/C#강좌)
	- 모든 WPF 프로그램은 최소한의 랜더링을 위한 백그라운드 쓰레드와 UI 스레드 (인터페이스 관리) 두개의 쓰레드로 기동된다. UI 스레드는 사용자 입력을 받고 화면을 그리고, 코드를 실행하고, 이벤트들을 처리한다.
	- WPF 는 기본적으로 STA(싱글 쓰레드) 모델을 지원하는데 하나의 쓰레드는 전체 응용프로그램에서 실행되고, 모든 WPF 객체를 소유하고 이쏙, TEXTBOX 같은 WPF UIElements 요소들은 쓰레드 선호도라는 것이 있어 다른 쓰레드와 상호작용을 할 수 없다.
	  ( ui 컨트롤ㄷ은 다른 쓰레드에서 업데이트 할 수 없다.)
	- 즉 화면을 그리는 쓰레드는 컨트롤을 소유하고 다른 쓰레드에서는 직접 접근할 수 없도록 되어있다. 이를 스레드 선호도라한다.
	- WPF 에서 멀티 쓰레드 처리를 위해서 Dispatcher 를 이용할 수도 있고 BackgroundWorker를 사용할 수도 있다.
	- Window 응용 프로그램 멀티 쓰레딩에서 가장 어려운 개념은 다른 스레드에서 UI 를 변경할 수 없다는 것이다. 대신 UI 스레드에서 메소드를 호춣해야 원하는 변경이 이루어진다.
	- 백그라운드 워커는 System.CompoonentModel 아래의 클래스로 코드를 별도의 스레드에서 동시에 비동기적으로 실행하게 해 주는데 응용프로그램의 기본 쓰레드와 자동으로 동기화 해준다. 
		호출 스레드는 정상적으로 실행이되고 백그라운드 워커는 백그라운드에서 비동기적으로 실행된다.
	- 백그라운드에서 작업을 실행하고 UI 실행등을 연기하는데 사용되는데 사용자는 UI가 계속 반응하기를 원하면서 (화면 작동이 계속 되어야한다든지) 데이터를 다운로드 한다든지, 
		오래걸리는 작업이 있어 진행사항을 표시해야 되는 경우, 데이터베이스 트랜잭션 처리 등에 유용하다.
	- 백그라운드 워커(BackgroundWorker - 백그라운드에서 무거운거 돌릴때 사용)
	- 백그라운드 워커 이벤트 
		: ProcessedChanged 이벤트 => 백그라운드 워커에서 일어나는 작업에 대해 변경이 생길때 호출되는 이벤트
		: RunWokerCompleted 이벤트 => 작업이 완료되었을 대 무언가를 할 수 있도록 지원
		: DoWork 이벤트 => 백그라운드 쓰레드가 할일을 기술 (DoWork 이벤트 처리 메소드 내용은 다른 백그라운드 다른 스레드에서 처리되므로 UI 쪽을 접근할 수 없는데 
			ReportProgress() 메소드를 호출하면 ProcessChanged 이벤트가 발생하여 UI를 업데이트하는 것이 가능하다.
		* ProcessedChanged와 RunWokerCompleted 이벤트는 BackgroundWorker가 만들어지는 것과 동일한 스레드에서 실행된다. 때문에 ProcessedChanged와 RunWokerCompleted 이벤트의 핸들러는 UI에 접근할 수 있다.
	- 백그라운드 워커는 일반적으로 기본/UI 스레드이므로 UI 를 업데이트 할 수 있다. 따라서 실행중인 백그라운드 작업과 UI 간에 수행 할 수 있는 유일한 통신방법은 ReportProgress 메서드를 사용하는 것이다.
	- DoWork 이벤트 처리 메소드 내부에서 파라미터가 필요하면 백그라운드 워커를 호출하는 RunWorkerAsync 메소드의 인수로 넣어주면 된다.
		int count = (int)e.Argument;
	- DoWork 이벤트 처리 메소드 내부에서 e.Result 등으로 어떤 결과값을 넣어두면 RunWorkerCompleted 이벤트 처리 메소드에서 e.Result 형태로 꺼내볼 수 있다.
	- DoWork 이벤트에 대한 이벤트 핸들러에서는 UI 컨트롤을 직접 접근할 수 없기 때문에 Dispatcher 를 통해서 UI 컨트롤에 접근해야한다.
		실행되는 동안에 Blocking 되어 다른곳에서는 사용할 수 없다.
	                    this.Dispatcher.BeginInvoke(DispatcherPriority.Normal,
                                                (ThreadStart)delegate ()
                                                {
                                                    if (i % 2 == 0)
                                                    {
                                                        sum += i;
                                                        e.Result = sum;
                                                        lstNumber.Items.Add(i);
                                                    }
                                                }
                         
                                                );
                    myThread.ReportProgress(i);
					
	- 백그라운드 워커 생성 및 실행 ( DoWork의 이벤트 핸들러 )(myThread.DoWork += myThread_DoWork)
		=> DoWork 이벤트 핸들러에서 Dispatcher 를 이용하여 UI 컨트롤에 값 설정
		=> DoWork 이벤트 핸들러에서 ProcessChanged 이벤트 발생을 위해 ReportProgress() 메서드 실행 (myThread.ReportProgress(i);)


	- WPF와 상관없이 UI를 비동기 처리하기 할경우 필요한 내용(윈폼도 같이 사용 가능할듯)
	
[ Visual Studio 팁 ]	

1. 상속받은 메서드 재정의를 위한 코드 자동 생성
	- override 또는 Visual Basic에서 Overrides 및 다음에 공백을 입력
	
https://learn.microsoft.com/ko-kr/visualstudio/ide/reference/generate-override?view=vs-2022	