1. C# 교과서 마스터하기 01. C# 교과서 책 마스터하기 시작, C# 강의, C# 강좌, C# 동영상 강의
2. C# 강의 - C# 교과서 마스터하기 02. 준비사항
	- windwos 10
	- visual studio 2019 설치 (https://my.visualstudio.com/Downloads?q=visual%20studio%202019&wt.mc_id=o~msft~vscom~older-downloads)
	- .Net Core 3.1 SDK 설치  (https://dotnet.microsoft.com/en-us/download)
	- .Net SDK 를 가지고 빌드
	
	
	- .Net Core SDK 설치
		start https://dot.net
	- visual stuido code 설치
		start https://code.visualstudio.com
	- visual studio community 설치
		start https://www.visualstudio.com
		
	- Microsoft Store 에서 Windows Terminal 설치
		=> 화면 탭 사용 가능
	
	- dotnet new -l
		console 형 dotnet 프로젝트 생성 옵션 조회
	- dotnet new console -o HellowWorldConsole
		console 기반으로 HellowWorldConsole 프로젝트 생성
	- console 모드에서 F7 키 : 직전 사용한 console 명령 조회
	- dotnet run
		현재 디랙토리의 프로젝트를 빌드해서 실행
	- code . 
		현재 프로젝트를 VisualStudio Code로 Open 하여 편집해라
		
	- ctrl + ee  key : 특정 코드를 테스트하고 싶을때 사용 (C# Interactive) (c# 대화형)
	
3. C# 강의 - C# 교과서 마스터하기 03. Hello, World
	- https://try.dot.net/
		=> 웹에서 c# 코드를 테스트할 수 있는 사이트
	- 코드 조각
		cw + tab + tab 누르면 Console.WriteLine(); 코드 가 자동 입력된다.
	- c#9.0 부터는 class 와 main 메서드가 없어도 코드가 실행 될 수 있다.
	- dotnet new console
		=> 현재 디렉토리 이름으로 console 프로젝트 생성하는 명령
	- Visual Studio Code 에서 View -> Terminal 에서 콘솔 명령으로 입력 가능
	- Linux (ubuntu) 에서 사용 가능
		Visual Studio Code 로 개발가능
		Windows Form와 WPF 는 Windwos 환경에서만 사용 가능
	- https://learn.microsoft.com/ko-kr/dotnet/csharp/
	- 마이크로 소프트 언어 포털
		https://www.microsoft.com/ko-kr/language/Search?&searchTerm=method&langID=457&Source=true&productid=0
		=> 해당 언어를 공식 사용
	- 닷넷 api 브라우저
		https://learn.microsoft.com/en-us/dotnet/api/
		
		
		
40. 대리자 (Delegate)
	- delegate void Runner();
	  static void RunnerCall(Runner runner) => runner();  // 넘어온 메서드 실행 (runner 가 어떤 메서드 이던간에 파라미터 형식과 리턴 형식만 맞으면 넘긴 메서드를 그대로 실행한다.)
	  
	- Action 대리자: 반환값이 없는 메서드를 대신 호출합니다
	- Func 대리자: 매개변수와 반환값이 있는 메서드를 대신 호출합니다
		Func<매개변수형식, 반환값형식>
		Func<매개변수형식, 매개변수형식,.. ,반환값형식>
	- Predicate 대리자: T 매개변수에 대한 bool 값을 반환하는 메서드를 대신 호출합니다
	
	- Func<int> getNumber1 = delegate () { return 1234; };   => 무명 메서드()
	  Func<int> getNumber2 = () => 1234;   => 람다식
	
	- Func<int, int> anonymous = delegate (int x) { return x * x; }; //① 익명 메서드 담기
	  Func<int, double> lambda = x => x / (double)2;                 //② 람다 식 담기
	  => 익명 메서드 대신 람다식을 많이 사용한다.
	  
	  
	- static void StringLengthPrint(Func<string, int> stringlength, string message)
	  => 첫번째 파라미터에 int 형을 리턴하는 함수를 넘기기 가능
		Func<string, int> stringlength = data.Length;  와 같은 표현
	  => String 으로 파라미터를 받고, int 형으로 return 하는 함수를 파라미터로 넘겨라.
	  = > stringlength 은 int StringLength(string data) 함수의 alias 같은 것
		
		
		
	- static void Main() => StringLengthPrint(StringLength, "안녕하세요.");
		=> 결국 StringLengthPrint (int, string) 형태
		
	- 함수형 프로그래밍 (https://mangkyu.tistory.com/111)
		데이터를 변환하는 함수의 조합으로 구성되는 프로그램 작성 방법. 함수의 출력은 입력에 의해서만 정해지고, 함수를 실행하는 명령어를 내포한 구조로 연결하여 프로그램을 작성한다. (네이버)
		함수형 프로그램은 기본적으로 람다형 문법을 따르는 방식 (https://blog.naver.com/sr_it_/222435285856)
		함수 파라미터에 함수를 넘기는 방식
		객체의 빌더 패턴과 유사
			필요한 함수들을 조합해서 사용
			String result = words.stream()
                .filter(w -> w.length() > 1)
                .map(String::toUpperCase)
                .map(w -> w.substring(0, 1))
                .collect(Collectors.joining(" "));
		C#에서 함수형 프로그램밍의 정점은 LINQ
			=> 특정 데이터를 결과를 다음 함수에 넘겨 연결해서 처리할 수 있다. (메서드 체이닝)(파이프라인 개념과 유사)
			
			
41. 이벤트
	- 1. Delegate 선언 (이벤트 핸들러)
	  2. Delegate 로 된 event 선언
	  3. event에 이벤트 핸들러 메서드 할당
	  4. 이벤트 발생
	  
46. 특성과 리플렉션
	- 닷넷 내장 특성
		Conditional : 특정 기호 선언여부일 경우 실행되고
			[Conditional("DEBUG")]		: 디버그 모드 인경우 실행하는 메서드
			[Conditional("RELEASE")]	: 릴리즈 모드 인경우 실행하는 메서드
		CallerMemberName : 호출한 멤버 이름 	
		CallerFilePath : 호출한 파일 경로
		CallerLineNumber : 호출한 소스 라인 번호
	- 사용자 지정 특성
		Attribute 클래스 상속해서 생성 가능
	- 클래스에 적용되어 있는 특성 목록 조회 하기
		Attribute[] attrs = Attribute.GetCustomAttributes(typeof(NickNameAttributeTest));
	- 리플렉션
		- 
            MemberClass m = new MemberClass();
            Type t = m.GetType();
            
            PropertyInfo pi = t.GetProperty("Name");			// 객체가 가진 특정  프로퍼티 객체 가져옴

            Console.WriteLine("속성 호출 : {0} ", pi.GetValue(m));

            MethodInfo mi = t.GetMethod("GetName");				// 객체가 가진 특정 method 가져옴

            Console.WriteLine("메서드 호출 : {0}", mi.Invoke(m, null));		// 가져온 method 를 실행

            dynamic d = new MemberClass();

            Console.WriteLine("속성 호출 : {0}", d.Name);

            Console.WriteLine("메서드 호출 : {0}", d.GetName());
		- 문자열로 지정된 클래스로 객체 생성하기 (Type과 Activator 클래스 이용)
			
			Type type = Type.GetType("TypeAndActivator.MyClass");
			dynamic objType = Activator.CreateInstance(type);
			objType.Test();
			
			
49. 확장 메서드
	- 원본 메서드를 변경하지 않고 기능을 추가할 수 있는 기능
	- 봉인(sealed) 클래스는 상속이 불가능하므로, 봉인 클래스에 있는 메서드 원래 기능을 변경없이 기능을 추가할 수 있다.
	- static 클래스에 static 메서드로 구현해야한다.
	- 확장 메서드의 첫 번째 매개변수에 this 키워드를 지정하여 확장 메서드를 사용할 개체 형식을 선택
	
	
51. 튜플
	- 메서드에 여러개의 매개 변수를 전달할때 사용자 정의 클래스로 넘길 수 있지만, 사용자 정의 클래스를 정의하지 않고 여러개의 값을 넘기도록 할 수 있는 기능 (c#7.0 부터 지원)
	- 튜플 리터럴 : 하나 이상 값을 설정하는 방식
		특별한 아이템 명을 지정하지 않으면 설정한 값만큼 Item1, Item2, ... 로 참조한다
		var fhd = (1920, 1080);
		fhd.Item1
		fhd.Item2
		
		사용할 아이템명 지정 가능
		var fhd = (Width:1920, Height:1080);
		fhd.Width
		fhd.Height
		
		이름과 형식을 지정가능
		(ushort Width, ushort Height) hd = (1920, 1080)
		fhd.Width
		fhd.Height
		
	- 튜플 리턴 
		(아이템1, 아이템2) 함수 ()
		{
			var r = (12,3);
			return r;
		}
	  
52. 클래스 라이브러리와 닷넷 스탠다드
	- 닷넷을 사용하는 모든 영역에서 공통으로 사용할 수 있는 API (특별한 경우가 아니면 닷넷 스탠다드로 라이브러리 개발)
	
53. 테스트
	- MSTest /NUnit / xUnit
	- TestClass 특성 : Test 대상 Class
	- TestMethod 특성 : Test 대상 Method 라는 의미
			
54. NuGet 패키지
	- 닷넷  패키지 관리자
	- 라이브러리를 전 세계 개발자와 공유하기 위한 기능 (Add-On 추가 기능 같은..?)
	- NuGet 패키지 생성 : 프로젝트 속성 -> 패키지 -> 빌드시 NuGet 패키지 생성  옵션 체크하여 빌드 (*.nupkg 파일 생성됨)
	- NuGet 에 게시 : nuget.org 사이트 
	- NuGet 에서 라이브러리 가져오기 : 프로젝트 -> 종속성 -> nuGet 패키지에서 가져오기 패키지에 추가해서빌드해야 DLL이 다운로드된다.
	
	
	
[ C# WPF ] 	

1. C#, WPF HelloWorld(XAML기반)_WPF교육추천(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육)
	- XAML 기반 MAIN START XAML 은 APP.XAML 에서 아래 설정으로 정의한다.
	StartupUri="MainWindow.xaml"> 
	
2. (닷넷C#, WPF기초강좌)C#코드 기반의 HelloWorld_WPF실무교육/자마린실무교육학원
	- 코드 기반 MAIN START XAML 은 CLASS 파일에서 STATREAD 의 MAIN 메서드를 정의하여 실행할 CLASS를 정의한다.
	        public static void Main(string[] args)
        {            
            [STAThread]
            MainWindow app = new MainWindow();
            app.Run();
        }
		
		=> C# 9.0 버전
		    var thread = new Thread(() =>
            {
                MainWindow app = new MainWindow();
                app.Run();
            });
            thread.SetApartmentState(ApartmentState.STA);
            thread.Start();
	- // C# 9 에서는 STAThread 특성 지원 안함 (참조 : https://www.sysnet.pe.kr/Default.aspx?mode=2&sub=0&pageno=8&detail=1&wid=12623_)

http://ojc.asia/bbs/board.php?bo_table=WPF&wr_id=3&sfl=wr_subject&stx=WPF%EA%B8%B0%EC%B4%88&sop=and


3. WPF 데이터바인딩 심플예제, 데이터 바인딩이용하여 오라클테이블 데이터를 ListView에 출력(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육/C#강좌)
	- ODP.NET 을 이용하여 오라클 DB 접속 (ODP.NET 을 사용하기 위해서는 Oracle Developer Tool for Visual Studio 를 설치해야한다) NuGet으로 설치가능하며, 사이트에서 다운로드 받아 설치도 가능
		https://www.oracle.com/database/technologies/net-downloads.html
		
		
4. (WPF추천 동영상교육)C# 코드기반 WPF HelloWorld(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육/C#강좌)
	- WPF는 싱글 스레드로 동작해야한다.
5. (WPF쓰레드강좌)WPF 멀티쓰레드 프로그래밍_WPF멀티스레드,백그라운드워커,BackgroundWorker(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육/C#강좌)
	- 모든 WPF 프로그램은 최소한의 랜더링을 위한 백그라운드 쓰레드와 UI 스레드 (인터페이스 관리) 두개의 쓰레드로 기동된다. UI 스레드는 사용자 입력을 받고 화면을 그리고, 코드를 실행하고, 이벤트들을 처리한다.
	- WPF 는 기본적으로 STA(싱글 쓰레드) 모델을 지원하는데 하나의 쓰레드는 전체 응용프로그램에서 실행되고, 모든 WPF 객체를 소유하고 이쏙, TEXTBOX 같은 WPF UIElements 요소들은 쓰레드 선호도라는 것이 있어 다른 쓰레드와 상호작용을 할 수 없다.
	  ( ui 컨트롤ㄷ은 다른 쓰레드에서 업데이트 할 수 없다.)
	- 즉 화면을 그리는 쓰레드는 컨트롤을 소유하고 다른 쓰레드에서는 직접 접근할 수 없도록 되어있다. 이를 스레드 선호도라한다.
	- WPF 에서 멀티 쓰레드 처리를 위해서 Dispatcher 를 이용할 수도 있고 BackgroundWorker를 사용할 수도 있다.
	- Window 응용 프로그램 멀티 쓰레딩에서 가장 어려운 개념은 다른 스레드에서 UI 를 변경할 수 없다는 것이다. 대신 UI 스레드에서 메소드를 호춣해야 원하는 변경이 이루어진다.
	- 백그라운드 워커는 System.CompoonentModel 아래의 클래스로 코드를 별도의 스레드에서 동시에 비동기적으로 실행하게 해 주는데 응용프로그램의 기본 쓰레드와 자동으로 동기화 해준다. 
		호출 스레드는 정상적으로 실행이되고 백그라운드 워커는 백그라운드에서 비동기적으로 실행된다.
	- 백그라운드에서 작업을 실행하고 UI 실행등을 연기하는데 사용되는데 사용자는 UI가 계속 반응하기를 원하면서 (화면 작동이 계속 되어야한다든지) 데이터를 다운로드 한다든지, 
		오래걸리는 작업이 있어 진행사항을 표시해야 되는 경우, 데이터베이스 트랜잭션 처리 등에 유용하다.
	- 백그라운드 워커(BackgroundWorker - 백그라운드에서 무거운거 돌릴때 사용)
	- 백그라운드 워커 이벤트 
		: ProcessedChanged 이벤트 => 백그라운드 워커에서 일어나는 작업에 대해 변경이 생길때 호출되는 이벤트
		: RunWokerCompleted 이벤트 => 작업이 완료되었을 대 무언가를 할 수 있도록 지원
		: DoWork 이벤트 => 백그라운드 쓰레드가 할일을 기술 (DoWork 이벤트 처리 메소드 내용은 다른 백그라운드 다른 스레드에서 처리되므로 UI 쪽을 접근할 수 없는데 
			ReportProgress() 메소드를 호출하면 ProcessChanged 이벤트가 발생하여 UI를 업데이트하는 것이 가능하다.
		* ProcessedChanged와 RunWokerCompleted 이벤트는 BackgroundWorker가 만들어지는 것과 동일한 스레드에서 실행된다. 때문에 ProcessedChanged와 RunWokerCompleted 이벤트의 핸들러는 UI에 접근할 수 있다.
	- 백그라운드 워커는 일반적으로 기본/UI 스레드이므로 UI 를 업데이트 할 수 있다. 따라서 실행중인 백그라운드 작업과 UI 간에 수행 할 수 있는 유일한 통신방법은 ReportProgress 메서드를 사용하는 것이다.
	- DoWork 이벤트 처리 메소드 내부에서 파라미터가 필요하면 백그라운드 워커를 호출하는 RunWorkerAsync 메소드의 인수로 넣어주면 된다.
		int count = (int)e.Argument;
	- DoWork 이벤트 처리 메소드 내부에서 e.Result 등으로 어떤 결과값을 넣어두면 RunWorkerCompleted 이벤트 처리 메소드에서 e.Result 형태로 꺼내볼 수 있다.
	- DoWork 이벤트에 대한 이벤트 핸들러에서는 UI 컨트롤을 직접 접근할 수 없기 때문에 Dispatcher 를 통해서 UI 컨트롤에 접근해야한다.
		실행되는 동안에 Blocking 되어 다른곳에서는 사용할 수 없다.
	                    this.Dispatcher.BeginInvoke(DispatcherPriority.Normal,
                                                (ThreadStart)delegate ()
                                                {
                                                    if (i % 2 == 0)
                                                    {
                                                        sum += i;
                                                        e.Result = sum;
                                                        lstNumber.Items.Add(i);
                                                    }
                                                }
                         
                                                );
                    myThread.ReportProgress(i);
					
	- 백그라운드 워커 생성 및 실행 ( DoWork의 이벤트 핸들러 )(myThread.DoWork += myThread_DoWork)
		=> DoWork 이벤트 핸들러에서 Dispatcher 를 이용하여 UI 컨트롤에 값 설정
		=> DoWork 이벤트 핸들러에서 ProcessChanged 이벤트 발생을 위해 ReportProgress() 메서드 실행 (myThread.ReportProgress(i);)


	- WPF와 상관없이 UI를 비동기 처리하기 할경우 필요한 내용(윈폼도 같이 사용 가능할듯)
	
6. (WPF동영상강좌)WPF 트리거(Trigger)란?_프로퍼티트리거(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육/C#강좌)
	- Trigger : 어떤 조건, 이번트 등 주어졌을 대 묵시적으로 컨트롤의 상태 또는 이벤트 핸들러등을 호출하는 기능
	- Style 의 Setter : 엘리먼트가 처음 생성되었을 때의 프로퍼티를 설정
	   Trigger : 프로퍼티가 변경되는 경우에 프로퍼티를 설정
	- Style 의 Triggers 프로퍼티sms TriggerBase 객체의 컬렉션인 TriggerCollection 타입
	  TriggerBase에서 파생된 클랙스 
		DataTrggier
		EventTrigger
		MultiDataTrigger
		MultiTrigger
		Trigger (Property Trigger)
	- Trigger (Property Trigger)
		<Trigger Property   형태
		특정 프로퍼티의 변화(어떤 값을 가졌을 때)에 내부에 정의한 Setter 컬렉션이 실행되는 트리거
		컨트롤이나 엘리먼트가 반응하는 방법을 정의하는 Trigger 이다. 
		대부분 이 프로퍼티는 IsMouseOver 프로퍼티와 같은 사용자의 입력 프로퍼티를 포함한다.
		이때 Trigger는 Setter에서 정의된 프로퍼티를 변경한다.
	-  정해진 Resource에 (<Window.Resources>) 접근할 때는 StaticResource 를 사용한다.
		<Button Width="100" Height="70" Style="{StaticResource MyStyle}" Content="Trigger" />
	
	
7. C#, WPF 기초강좌 WPF Trigger 데이터 트리거(Data Trigger)(WPF동영상/WPF강의/C#동영상/C#강의/C#교육/닷넷교육/C#강좌)
	- Data Trigger
		<DataTrigger>  형태 (트리거는 의존 속성이 아닌 속성에 사용)
		프로퍼티 트리거의 Property 를 바인딩(Binding) 으로 대신
		바인딩 되는 값이 특정 값을 가질 때 프로퍼티를 설정할 수 있게 해준다.
	- Style
		HTML 의 Style 시트 처럼 Style 을 미리 정의해놓고 해당 Style을 사용할 Tag에서 지정해서 사용한다.
	- DataContext : Source 객체를 지정. xaml 에서 바인딩된 객체가 가지고 있는 속성 참조할 수 있음 (<TextBox Grid.Row="2" Text="{Binding TheValue}" />)
		양방향 공유라서 화면에서 데이터 변경 시 해당 객체의 값이 변경된다.
	
		public MainWindow()
        {
            InitializeComponent();

            DataContext = new DataObject();
        }
	
8. (WPF강좌)ListBox와 LINQ쿼리데이터바인딩, 새창띄우기, 이벤트 및 델리게이트를 통한 메인 윈도우리스트박스리프레쉬(WPF동영상/WPF강의/C#동영상/C#강의/C#교육)
	- ObservableCollection<Duty> : Collection에 값이 들어오고 나갈때 자동으로 감지하기 위해 상속 받음
		public class Duties : ObservableCollection<Duty>
	
	
[ Visual Studio 팁 ]	

1. 상속받은 메서드 재정의를 위한 코드 자동 생성
	- override 또는 Visual Basic에서 Overrides 및 다음에 공백을 입력
	
https://learn.microsoft.com/ko-kr/visualstudio/ide/reference/generate-override?view=vs-2022	





[ WPF Modern Flat UI ]
#. WPF C# Professional Modern Flat UI Tutorial
	- https://www.youtube.com/watch?v=PzP8mw7JUzI&t=730s
	- https://velog.io/@tataki26/WPF-ModernDesign-%EC%8B%A4%EC%8A%B5
	
	

타키탸키

로그인
타키탸키

로그인
[WPF] ModernDesign 실습
tataki26·2022년 1월 12일

1
Cwpf실습
C언어(C, C++, C#)
목록 보기
14/14


post-thumbnail

MVVM 패턴

[이미지 출처: https://blog.yena.io/studynote/2019/03/16/Android-MVVM-AAC-1.html]

MVVM
Model - View - ViewModel의 하나의 소프트웨어 구조 패턴(소프트웨어 아키텍처)
UI와 Logic을 분리하기 위해 사용
View가 데이터를 실시간으로 관찰(Observable 패턴) >> 자동으로 UI 갱신
UI 변경(ViewModel)에 따른 Logic 변경(Model) 최소화
(단위) 테스트 용이
UI 디자인과 상관 없이 미리 정의된 Model과 ViewModel을 먼저 개발 가능
ObservableObject.cs
ViewModel의 기본이 되는 프로퍼티들이 정의 됨
관찰 가능한 개체 생성
INotifyPropertyChanged 인터페이스를 구현한 기본 클래스
ViewModel을 이 클래스에서 상속 받아 만들 수 있다
namespace ModernDesign.Core
{
    class ObservableObject : INotifyPropertyChanged
    {
        // 구현 강제에 따라 자동으로 정의
        public event PropertyChangedEventHandler PropertyChanged;
        
        // name에 해당하는 이름을 가진 데이터가 변화할 때마다 이벤트 발생시키는 메서드
        protected void OnPropertyChanged([CallerMemberName] string name = null)
        {
            // PropertyChanged가 null이 아니면 Invoke 호출
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }
    }
}
RelayCommand.cs
참고: http://ojc.asia/bbs/board.php?bo_table=WPF&wr_id=146
전통적인 이벤트 기반 프로그래밍
컨트롤에 이벤트 핸들러 메서드를 코드 비하인등서 연결하여 사용자 이벤트 처리
이벤트 처리 핸들러를 재사용하거나 단위 테스트 수행이 어려움
XAML UI MVVM
버튼 사용 시, Click 이벤트 핸들러를 이용하기 보다는 Command를 이용하기를 권장
여러 버튼에서 하나의 Command 공유 가능
모든 컨트롤마다 Click 이벤트 만들 필요 없음
WPF Command
ICommand 인터페이스를 구현하여 만든다
Execute, CanExecute 메서드
CanExecuteChanged 이벤트
Execute
실제 처리해야 하는 작업 기술
CanExecute
Execute 메서드의 코드를 실행할지 여부를 결정하는 코드 기술
false 리턴 시, Execute 메서드 호출하지 않음
명령 사용 여부 확인을 위해 WPF에 의해 호출 됨
키보드 GET포커스, LOST포커스, 마우스 업 등의 UI 상호 작용 중 발생
Command 패턴의 주체
서비스를 요청하는 클라이언트(손님)
명령을 서술하는 Command Object(주문서)
명령을 요청하는 Command Invoker(웨이터)
특정 명령을 실제 처리하는 Command Receiver(Target, 요리사)
RelayCommand
View에는 이벤트 처리 메서드가 없지만 사용자가 버튼을 클릭하면 프로그램이 이에 반응하고 사용자의 요청에 응답한다
컨트롤들의 Command 속성이 설정되었기 때문
이러한 바인딩은 사용자가 컨트롤을 클릭하면 ViewModel 실행을 통해 ICommand 개체가 공개되도록 한다
ICommand를 구현하는 RelayCommand는 xaml에서 선언된 View에서 ViewModel의 기능을 손쉽게 사용할 수 있도록 해주는 어댑터
ViewModel 외부에서 RelayCommand 정의 가능
CommandManager의 RequerySuggested 이벤트
사용자 정의 명령의 경우, CanExecute 메서드가 대부분의 시나리오에서 호출되지 않음
CanExecuteChanged 이벤트를 RequerySuggested 이벤트에 연결
특정 조건에 따라 버튼을 활성화/비활성화 가능
CommandManager가 명령 실행에 영향을 줄 수 있는 변경 사항이 있다고 생각할 때마다 발생
이때마다 CanExecute 호출(강제 실행 가능)
명령 실행 기능이 변경되었다고 생각할 때마다(실제로 변경되지 않았다 하더라도) CanExecuteChanged를 발생
CanExecuteChanged 이벤트
CanExecute 메서드가 호출되어 CanExecute의 상태가 변경될 때 발생하는 이벤트
해당 ICommand에 바인딩 된 모든 명령 소스(버튼 등)에 CanExecute에 의해 반환된 값이 변경 되었음을 알린다
WPF는 CanExecute를 호출하고 Command에 연결된 컨트롤의 상태 변경
namespace ModernDesign.Core
{
   class RelayCommand : ICommand
    {
        private Action<object> _execute;
        private Func<object, bool> _canExecute;

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

	// 생성자
        public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
        {
            _execute = execute;
            _canExecute = canExecute;
        }
        
        // CommandManager.RequerySuggested 이벤트가 호출될 때마다 실행
        // 즉, CanExecuteChanged 이벤트가 호출될 때마다 실행
        // false 리턴 시, Execute 메서드 호출하지 않음
        public bool CanExecute(object parameter)
        {
            // 첫번째 식이 true이면 이를 리턴하고 false면 두번째 식 리턴
            return _canExecute == null || _canExecute(parameter);
        }
        
        public void Execute(object parameter)
        {
            _execute(parameter);
        }
    }
}
MainWindow.xaml
Border
여러가지 컨트롤들을 감싸안고 배경과 테두리를 설정할 수 있게 해주는 컨트롤
자식으로 단 1개의 컨트롤 밖에 가질 수 없다
여러가지 컨트롤을 묶으려면 Grid나 StackPanel로 묶은 후 Border로 묶으면 된다
<Border Background="#272537"
            CornerRadius="20">
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="20"/>
                <ColumnDefinition/>
            </Grid.ColumnDefinitions>

            <Grid.RowDefinitions>
                <RowDefinition Height="75"/>
                <RowDefinition/>
            </Grid.RowDefinitions>
        </Grid>
    </Border>
TextBox
하나의 박스에 대해 하나의 색깔, 사이즈, 폰트만 적용 가능
고정된 라인 높이 폭을 가지고 줄 간격도 통일
내부에 다른 태그를 넣을 수 없다
출력과 편집 기능을 동시에 가지고 있다
입력이 가능하다
<TextBox Width="250"
         Height="40"
         VerticalAlignment="Center"
         HorizontalAlignment="Left"
         Margin="5"
         Grid.Column="1"/>
ContentControl
Content 속성을 지닌 컨트롤
Button, Label, Frame 등
<ContentControl Grid.Row="1"
                Grid.Column="1"
                Margin="10"/>
DataContext
컨트롤의 계층 구조를 통해 모든 바인딩의 기초를 설정하는 것
DataContext를 사용하면 데이터 바인딩을 할 때, 하나의 객체를 여러 개로 바인딩할 필요X
부모 요소에 DataContext를 줘서 그 부모를 데이터 바인딩 하면 된다
각 바인딩에 대한 소스를 수동으로 정의하는 번거로움이 줄어든다
xmlns:viewModel="clr-namespace:ModernDesign.MVVM.ViewModel"

<Window.DataContext>
        <viewModel:MainViewModel/>
    </Window.DataContext>
    
		...
        
<ContentControl Grid.Row="1"
                Grid.Column="1"
                Margin="10"
                Content="{Binding CurrentView}"/>
MenuButtonTheme.xaml
Resource
한 번 이상 혹은 자주 사용하기를 원하는 자원
필요할 때 재사용할 수 있도록 임시로 특정 공간에 저장됨
CPU의 캐시된 메모리와 유사
모든 객체는 리소스로 정의될 수 있다
고유 키는 XAML 리소스에 지정된다
이 키를 이용해 Static Resource 혹은 Dynamic Resource 태그를 사용하여 참조 가능
Resource를 사용하는 이유
재사용성
공통 파일에서 단 한 번만 정의하고 여러 XAML에서 사용 가능
Grid, Stackpanel 등 같은 panel 내에서 정의 가능
사용 범위가 전역
전체 응용프로그램인 경우 데이터를 로컬로 저장
Static Resource
참조 요소에 의해 한 번만 검색되며 리소스 전체 수명에 사용
페이지를 새로 로드하는 것과 같은 런타임 동작을 기반으로 다시 검색되지 않는다
성능적인 우위를 가진다
Button Style="{StaticResource ResourceKey}"></Button>
Dynamic Resource
런타임 시 변경될 여지가 있는 리소스에 사용
리소스가 참조될 때마다 다시 읽어오기 때문에 성능 저하 발생
Button Style="{DynamicResource ResourceKey}"></Button>
ResourceDictionary
정의된 리소스, 사용 중인 리소스들을 딕셔너리에 담고 파일 별로 나누는 것
파일을 세분화시켜 정리하기 때문에 유지보수에 용이하다
리소스 병합
Resource.MergedDictionaries
여러개의 리소스 딕셔너리들을 메인 리소스 영역에 연결시키는 것
XAML 개체 요소 사용
{x:Type TypeName="prefix:typeNameValue"/>
prefix: 선택 사항, 네임 스페이스 매핑용 접두사
typeNameValue: 필수 요소, 형식 이름
Template
일련의 부모 자식 관계를 갖는 요소(컨트롤)들을 생성할 수 있는 정의서
Root 요소와 그 아래 자식, 그리고 그 아래 자식 등 각각의 요소 속성을 선언하는 것
ControlTemplate
Control 그 자체의 외형을 정의하는 요소
Style 작성 방법
<Style>
  <Setter Property="속성" Value="값">
</Style>
HorizontalAlignment

[이미지 출처: https://wpf.2000things.com/tag/horizontalalignment/]
TemplateBinding
ControlTemplate을 정의할 때 부모 컨트롤의 속성을 받아들이기 위해 사용
Binding보다 가볍다
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Style BasedOn="{StaticResource {x:Type ToggleButton}}" // ToggleButton 스타일 사용
           TargetType="{x:Type RadioButton}" // 대상 타입은 RadioButton
           x:Key="MenuButtonTheme"> // 타입명
        <Style.Setters> // Style에 속하는 Setter 객체의 목록을 가져온다
            <Setter Property="Template">
                <Setter.Value>
                    // 바인딩을 위해 타겟 타입을 지정해줘야 한다
                    <ControlTemplate TargetType="RadioButton">
                        <Grid VerticalAlignment="Stretch"
                              HorizontalAlignment="Stretch"
                              Background="{TemplateBinding Background}">

			    // main window의 라디오 버튼의 문구(Content)와 바인딩
                            <TextBlock Text="{TemplateBinding Property=Content}"
                                       VerticalAlignment="Center"
                                       Margin="50,0,0,0"/>
                        </Grid>
                        </ControlTemplate>
                </Setter.Value>
            </Setter>

	    // Setter Property 여러 개 설정 가능
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="BorderThickness" Value="0"/>
        </Style.Setters>
        
        <Style.Triggers>
            <Trigger Property="IsChecked" Value="True"> // 버튼 체크 여부
                <Setter Property="Background" Value="#22202f"/> // 색 변경
            </Trigger>
        </Style.Triggers>
적용
// MainWindow.xaml

<StackPanel Grid.Row="1">
    <RadioButton Content="Home"
                 Height="50"
                 Foreground="White"
                 FontSize="14"
                 Style="{StaticResource MenuButtonTheme}"
                 IsChecked="True"
                 // HomeViewCommand와 바인딩
                 Command="{Binding HomeViewCommand}"/>

// 여러 개 사용 가능
// 하나의 StackPanel로 묶여 있어 자동으로 효과가 적용된다
    <RadioButton Content="Discovery"
                 Height="50"
                 Foreground="White"
                 FontSize="14"
                 Style="{StaticResource MenuButtonTheme}"
                 Command="{Binding DiscoveryViewCommand}"/>
</StackPanel>
App.xaml
정의된 리소스 딕셔너리는 App.xaml 의 메인 리소스 영역에 추가하여 사용 가능
XAML 네임스페이스
XML 네임스페이스 개념의 확장
C# 네임스페이스와 대응되는 개념(xmlns= = using 구문)
태그의 중복을 막기 위해 사용
첫번째 선언
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
전체 WPF 클라이언트/프레임워크 XAML 네임스페이스를 기본값으로 매핑
두번째 선언
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
개별 XAML 네임스페이스를 대개 x: 접두사에 매핑
XAML 언어 정의의 일부인 내장 항목을 지원
WPF는 XAML을 언어로 사용
사용자 지정 클래스 매핑
clr-namespace
요소로 노출되는 공용 형식을 포함하는 어셈블리 내에서 선언된 CLR 네임스페이스
콜론(:)으로 토큰과 해당 값을 구분
해당 클래스의 경로 지정
DataTemplate
데이터 개체의 시각화를 지정
ListBox 등의 ItemsControl을 전체 컬렉션에 바인딩하는 경우에 특히 유용
DataTemplate의 콘텐츠는 데이터 개체의 표시 구조가 된다
<Application x:Class="ModernDesign.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:ModernDesign"
             xmlns:viewModel="clr-namespace:ModernDesign.MVVM.ViewModel"
             xmlns:view="clr-namespace:ModernDesign.MVVM.View"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Theme/MenuButtonTheme.xaml"/>
                <ResourceDictionary Source="Theme/TextboxTheme.xaml"/>
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
        
        <DataTemplate DataType="{x:Type viewModel:HomeViewModel}">
                <view:HomeView/>
            </DataTemplate>
         
    </Application.Resources>
</Application>
TextboxTheme.xaml
x:Name
XAML 상에서 각각의 Item들에 이름을 붙여줄 수 있는 Attribute
코드 비하인드에서 해당 Item을 참조(사용)할 수 있는 Field를 만들어 준다
Data Trigger
바인딩 되는 값이 특정 값을 가질 때 프로퍼티 설정 가능
<Grid>
    <Rectangle StrokeThickness="1"/> // 윤곽선 두께 설정
    <TextBox Margin="1"
             Text="{TemplateBinding Text}"
             BorderThickness="0"
             Background="Transparent"
             VerticalContentAlignment="Center"
             Padding="5"
             Foreground="#CFCFCF"
             x:Name="SearchBox"/>
             
             // 검색창에 아무 것도 입력되지 않았을 때 기본으로 뜨는 문구
             <TextBlock IsHitTestVisible="False" // 사용자의 클릭 입력을 무시한다
                        Text="Search"
                        VerticalAlignment="Center"
                        HorizontalAlignment="Left"
                        Margin="10,0,0,0"
                        FontSize="11"
                        Foreground="DarkGray"
                        Grid.Column="1">

                 <TextBlock.Style>
                     <Style TargetType="{x:Type TextBlock}">
                         <Style.Triggers>
                             // 아무것도 입력 안 됐을 때 보이도록 설정
                             <DataTrigger Binding="{Binding Text, ElementName=SearchBox}" Value="">
                                 <Setter Property="Visibility" Value="Visible"/>
                             </DataTrigger>
                         </Style.Triggers>
                         // 글이 입력되면 사라진다
                         <Setter Property="Visibility" Value="Hidden"/>
                     </Style>
                 </TextBlock.Style>
              </TextBlock>
</Grid>
MainViewModel.cs
ViewModel

Model에 있는 데이터의 상태
데이터를 제어하는 코드들을 가진다
바인더(binder, 연결자)
ViewModel에 있는 View에 연결된 속성과 View 사이의 통신을 자동화하는 역할
Property가 변하면 View에 자동으로 반영된다
MainViewModel 클래스
ObservableObject를 상속
MainViewModel 메서드
HomeViewModel 객체 생성
using System;
using ModernDesign.Core;

namespace ModernDesign.MVVM.ViewModel
{
    class MainViewModel : ObservableObject
    {
    	// 사용자가 컨트롤 클릭 시, ICommand 개체 공개
    	public RelayCommand HomeViewCommand { get; set; }
        public RelayCommand DiscoveryViewCommand { get; set; }
        
        public HomeViewModel HomeVM { get; set; }
        public DiscoveryViewModel DiscoveryVM { get; set; }
        
        private object _currentView;

	// 의존 프로퍼티
        // 외부에서 접근 시, 프로퍼티를 통해 값을 설정하고 조회
        // _currentView를 설정, 조회하는 방법 정의
        public object CurrentView 
        {
            get { return _currentView; } // _currentView의 값을 바로 읽는다
            set
            {
                // CurrentView에 설정되는 값을 바로 _currentView에 저장
                _currentView = value;
                OnPropertyChanged();
            }
        }
        
        // Home과 Discovery를 클릭할 때, 서로 다른 화면이 나온다
        public MainViewModel()
        {
            HomeVM = new HomeViewModel();
            DiscoveryVM = new DiscoveryViewModel();
            
            CurrentView = HomeVM;
            
            HomeViewCommand = new RelayCommand(o =>
            {
                CurrentView = HomeVM;
            });
            
            DiscoveryViewCommand = new RelayCommand(o =>
            {
                CurrentView = DiscoveryVM;
            });
        }
    }
}
HomeViewModel.cs
HomeView.xaml
UserControl
사용자 정의 컨트롤
특정 UI 구현을 반복하거나 이전의 프로그램 UI를 같이 사용하고 싶을 때 사용
윈도우 전체가 아닌 일부를 구현할 때 사용
LinearGradientBrush
선형 그라데이션으로 영역을 그리는 방법
두 개의 color 객체와 point 객체가 필요
color1 객체는 point1의 위치에 칠해지고 color2 객체는 point2 위치에 칠해진다
offset
컨트롤의 상대 좌표
시작 포인트에서 얼마나 떨어진 곳에 위치할 것인가를 백분위로 나타낸 것
clip

[이미지 출처: http://gushwell.ldblog.jp/archives/52315073.html]
<Border.Background>
    <LinearGradientBrush StartPoint="0,0" EndPoint="1,2">
        <GradientStop Color="#5bc3ff" Offset="0.0"/>
        <GradientStop Color="#3aa0ff" Offset="1"/>
   </LinearGradientBrush>
</Border.Background>

// 사각형 모퉁이 둥글게 하기 - CornerRadius="10"와 같은 결과
<Border.Clip>
    <RectangleGeometry RadiusX="10"
                       RadiusY="10"
                       Rect="0,0,400,200"/>
</Border.Clip>
참고: https://www.youtube.com/watch?v=PzP8mw7JUzI&t=657s
	
	
	
	- https://velog.io/@tataki26/WPF-Modern-UI-%EC%8B%A4%EC%8A%B5
	
MainWindow.xaml
결과 창을 확인하며 디자인 할 수 있는 영역
마크업 언어(.xaml)를 사용
윈도우(창) 설정
<Window x:Class="MordernUI.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:MordernUI"
        mc:Ignorable="d"
        Title="MainWindow" Height="500" Width="900" // 창 크기 설정
        WindowStyle="None" // 윈도우 커스터마이징 가능
        ResizeMode="NoResize"
        Background="#181735"> // 배경색 설정
Grid

열과 행으로 테이블 형태의 레이아웃 제공
Grid.RowDefinitions: 행
Grid.ColumnDefinitions: 열
<Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="25"/>
            <RowDefinition/>
        </Grid.RowDefinitions>

        <Grid.ColumnDefinitions>
            <ColumnDefinition/>
            <ColumnDefinition/>
        </Grid.ColumnDefinitions>

        <Grid Background="#0F0F2D"
              Grid.ColumnSpan="2" // 2번 인덱스의 그리드
              MouseDown="Grid_MouseDown"> // 이벤트 핸들러

            <Grid.ColumnDefinitions> // 열이 14칸으로 나누어진다
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
                <ColumnDefinition/>
            </Grid.ColumnDefinitions>
            ......
</Grid>
TextBlock
블록 단위로 문자열 출력
블록별 커스터마이징 가능
텍스트마다 다른 폰트 색, 배경 색, 크기 등의 다양한 속성 각기 적용 가능
출력만 가능하고 선택 및 편집은 불가능
WPF에 폰트 적용하기
폰트 파일을 프로젝트 폴더 안에 넣기
visual studio 상의 폴더 안에도 넣어준다
FontFamily=경로/#폰트 이름
폰트 이름은 폰트 파일 내부에 있는 이름으로 사용
<TextBlock Text="TakiTyaki" // 출력 문구
                       Foreground="White" // 글자 색
                       Grid.Column="1" // 그리드 상 위치
                       VerticalAlignment="Center" // 열 정렬
                       HorizontalAlignment="Center" // 행 정렬
                       FontFamily="Fonts/#Dosis" // 폰트 설정
                       FontWeight="Medium"/>
버튼

Button Content
버튼 색, 폰트 크기, 여백 등을 설정할 수 있다
<Setter Property>
엘리먼트가 처음 생성되었을 때 프로퍼티 설정
폰트, 배경색, 커서 모양 등 설정 가능
<Style.Triggers>
특정 프로퍼티의 변화(특정 값을 가졌을 때)에 내부에 정의한 Setter 컬렉션 실행
<Button.Template>
버튼 컨트롤을 사용자가 원하는 모양으로 변경 가능하도록 도와주는 기능
{TemplateBinding Background}
부모 컨트롤러의 속성을 받아들인다
Control Template을 버튼 내부에 정의할 때, 템플릿과 버튼 속성을 바인딩시키기 위해 필요
예:) 템플릿 내의 Rectangle 요소와 버튼의 Width 맞추기
<Button Content="Start" // 출력 문구
                        Foreground="White"
                        FontSize="10"
                        FontWeight="Medium"
                        Margin="0,0,10,0"
                        Grid.Column="12"
                        Grid.ColumnSpan="2">

                <Button.Style>
                    <Style TargetType="Button"> // 반드시 설정
                        <Setter Property="TextElement.FontFamily" Value="Fonts/#Dosis"/>
                        <Setter Property="Background" Value="#FE6584"/>
                        <Setter Property="Cursor" Value="Hand"/>
                        <Style.Triggers>
                            // 마우스 포인터가 위치하는지 여부
                            <Trigger Property="IsMouseOver" Value="True"> 
                                <Setter Property="Background" Value="#FF4C70"/>
                            </Trigger>
                        </Style.Triggers>
                    </Style>
                </Button.Style>

                <Button.Template>
                    <ControlTemplate TargetType="Button">
                        <Border Width="75" Height="15"
                                    CornerRadius="8" // 가장자리 둥글게
                                    Background="{TemplateBinding Background}"> 
                            <ContentPresenter VerticalAlignment="Center"
                                                  HorizontalAlignment="Center"/>
                        </Border>
                    </ControlTemplate>
                </Button.Template>
            </Button>
StackPanel

가로 또는 세로 방향으로 지정할 수 있는 단일 선에 따라 자식 요소를 결정하는 패널
가로는 가로로, 세로는 세로로 쭉 정렬해주는 패널
<StackPanel Grid.Row="1"
                    VerticalAlignment="Center"
                    Margin="60">

            <StackPanel>
                <StackPanel Orientation="Horizontal"
                            Margin="0,0,0,20">
                    <Image Width="50" Height="50"
                       Source="Images/rocket.png"
                       // 이미지 스케일링 조정(확대 시) 화질 개선
                           RenderOptions.BitmapScalingMode="Fant"/>
                    <TextBlock Text="TakiTyaki"
                           Foreground="White"
                           FontSize="20"
                           FontWeight="Medium"
                           VerticalAlignment="Center"
                           FontFamily="Fonts/#Dosis"
                               Margin="10,0,0,0"/>
                </StackPanel>
출처: https://www.youtube.com/watch?v=PzP8mw7JUzI	




[ LOT TRANS ]
CREATE TABLE `mes_lot_mas` (
  LOT_ID varchar(50) not null,
  LAST_EVENT_TIMEKEY varchar(50) not null,
  LAST_EVENT_CD		 varchar(50) not null,
  FAC_ID varchar(50) not null,
  PROD_ID varchar(50) not null,
  FLOW_ID varchar(50) not null,
  OPER_ID varchar(50) not null,
  EQP_ID varchar(50) not null,
  PROD_QTY int(11),
  LOT_STAT_CD varchar(50) not null,
  CREATE_DATE date,
  CREATE_USER varchar(50),
  UPDATE_DATE date ,
  UPDATE_USER varchar(50),
  PRIMARY KEY (LOT_ID)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4;



CREATE TABLE `mes_lot_his` (
  LOT_ID 	varchar(50) not null,
  TIMEKEY 	varchar(50) not null,
  EVENT_CD	varchar(50) not null,
  FAC_ID 	varchar(50) not null,
  PROD_ID 	varchar(50) not null,
  FLOW_ID 	varchar(50) not null,
  OPER_ID 	varchar(50) not null,
  EQP_ID 	varchar(50) not null,
  PROD_QTY int(11),
  LOT_STAT_CD varchar(50) not null,
  OLD_PROD_ID varchar(50) not null,
  OLD_FLOW_ID varchar(50) not null,
  OLD_OPER_ID varchar(50) not null,
  OLD_EQP_ID varchar(50) not null,
  OLD_PROD_QTY int(11),
  CREATE_DATE date,
  CREATE_USER varchar(50),
  UPDATE_DATE date ,
  UPDATE_USER varchar(50),
  PRIMARY KEY (LOT_ID, TIMEKEY)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4;




#.  C#, WPF 동영상, 의존프로퍼티(DependencyProperty), 의존속성
	- 의존속성 값이 변경되면 자동으로 언떤 것을 로드되게 하거나 랜더링 되도록 할수 있게 하는것. 애니메이션, 스타일링, 데이터바인딩에 주로 사용
	- 어떤 속성을 애니메이션 시켜야 하거나 데이터 바인딩을 하려면 그 속성은 반드시 의존 속성이어야한다.
	- 기본으로 제공되는 UI 컨트롤은 대부분의 속성이 의존 속성으로 되어있다.


#.  (C#, WPF동영상강좌)WPF이벤트라우팅(RoutedEvent), 버블링(Bubbling), 터널링(Tunneling) 이벤트
	- 라우팅 이벤트 종류
		버블링 : 현재 컨트롤에서 상위로 올라가면서 전달되는 경우
		터널링 : 자식 컨트롤로 전달되는 경우	(접두사로 Preview를 붙임. PreviewMouseDown)
			부모 이벤트가 먼저 실행되므로, 자식 이벤트 발생을 막거나 자식이벤트 처리 전에 부모 요소가 무엇인가 수행할 필요가 있는 경우에 유용하다
		다이렉트 이벤트 : 하나의 엘리먼트에서만 발생되는 경우
	- 이벤트 라우팅 : 어떤 이벤트가 컨트롤의 하위 또는 상위로 전달되는 것
	- 이벤트 핸들러 메소드는 RouteEventArgs 매개변수를 가지는데 Source 속성을 통해 실제 이벤트를 발생시킨 요소에 대한 참조를 제공한다.
	- ButtonBaseClick : 버튼계역의 모든 click 이벤트에 대한 처리 핸들러 지정
	- 상위로 라우팅 되는 것을 막으려면 RoutedEventArgs 의 Handled 속성을 true로 설정하면된다.
	
#. C#,WPF 데이터바인딩(DataBinding)이란?
	- <TextBox Name="txt1" Text="{Binding Mode=OneWay}" />
	  <TextBox Name="txt2" Text="{Binding Source={x:Reference txt1}, Path =Text}" />
	  txt1 에 text 를 변경하면 txt2 에 같이 변경
	  {Binding Mode=OneWay} : txt1 -> txt2 으로만 한다는 의미 
	  Source={x:Reference txt1} : 참조할 컨트롤을 txt1 지정
	  Path =Text : 참조한 컨트롤의 참조할 속성
	- 데이터 바인딩은 소스와 타겟이 필요하며, 일반적으로 소스는 데이터(ViewModel) 이고, 타겟은 컨트롤
	- 데이터 바인딩 처리는 타겟에 한다.
	- 모든 바인딩에는 소스 객체, 소스 속성, 타겟 객체, 타겟 속성이 있다.
	- UI 컨트롤 객체의 소스 객체는 Binding Source 속성 또는 ViewModel 클래스인 경우 DataContext 속성으로 지정
	- Window 에 DataContext 속성을 지정하면 하위의 컨트롤에서 해당 DataContext 에 바인딩된 객체를 사용 가능하다.
	- 데이터 바인딩은 이밴트 핸들러는 대체할 수 있어서 C# 코드를 줄이는 역할을 한다.
	- Window에 DataConext 속성에 객체를 할 당할 수 있는 방법
		1) XAML 에서 정의
		    <Window.DataContext>
				<viewModel:MainViewModel/>
			</Window.DataContext>
		2) XAML Behind 코드에서 정의 (.cs)
			this.DataContext = 객체명;
	- txt2 에서 txt1 으로 변경하려면 타겟쪽인 txt2 에서 UpdateSourceTrigger = PropertyChanged 지정하여야한다. (대부분 의존 속성 기본값이 PropertyChanged 인 반면, Text 속성인 경우 기본값은 LostFocus 가 기본이다.)
		<TextBox Name="txt2" Text="{Binding Source={x:Reference txt1}, Path =Text, UpdateSourceTrigger = PropertyChanged}" />
	- <TextBox Text="{Binding Path=Text}" />
		소스 객체를 지정하지 않은 경우 DataContext에 할당된 객체를 참조하여 해당 객체의 속성중 Text 속성을 참조한다.
		아래와 같이 표기할 수도 있다.
		<TextBox>
			<TextBox.Text>
				<Binding Path="Text" />
			</TextBox.Text>
		</TextBox>			
	- 더 축약된 표현 (Path 생략 가능) : <TextBox Text="{Binding Text}" />
	- <TextBox Text="{Binding Path=.}" />  : 소스의 속성에 바인딩하지 않고, 소스객체 자체에 바인딩하려는 경우 점을 사용
	
#. C#, WPF 데이터바인딩 실습 동영상, DataBinding Mode
	- Binding 시 소스 속성 지정 방식 (컨트롤 연동)
		1) {Binding Source={x:Reference txt1}, Path=Text}
		2) {Binding ElementName=txt1, Path=Text}
	- Binding 시 특정 객체 속성 참조 방법
		1) <TextBox x:Name="txtName" Text="{Binding SelectedEmp.Ename}" /> : 객체명.속성명
		2) DataContext 이용
	- Binding 방법
		1) XAML 에서 Binding 로 하는 방법
			<Label Content={Binding ElementName=txt1, Path=Text />
		2) Behind 코드로 Biding 하는 방법
			Binding bind = new Binding();
			bind.Source = txt1;
			bind.Path = PropertyPath(TextBox.TextProperty);
			// SetBinding의 첫번재 인자는 DependencyProperty 타입이 되어야한다.
			// 그러므로 타겟의 속성은 의존속성의 지원을 받는 속성이 되야한다.
			label.SetBinding(Label.ContentProperty, bind);
	- Binding Mode
		OneWay : 한쪽 방향
		TwoWay : 양방향
		OneTime : 한번만
		OneWayToSource : 소스, 타겟의 의미가 반대되는 의미
		
		
		
#. (C#,WPF동영상)WPF 데이터바인딩 실습, INotyfyPropertChanged, PropertyChanged 이용		
	- 소스 객체가 UI 컨트롤이 아닌 일반 클래스인 경우 클래스의 프로퍼티가 변경된 경우 타겟 객체에 알릴 수 있는 매커니즘
	- INotyfyPropertChanged 를 상속받은 클래스에서 PropertyChangedEventHandler를 기본으로하는 PropertyChanged 이벤트를 정의하면 타겟 객체에 알릴 수 있다.
	- 해당 프로퍼티 클래스로 모든 프로퍼티 변경 알림 처리가 가능하다.
	class ObservableObject : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged([CallerMemberName] string name = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }
    }
	
	
	- PropertyChangedEventArgs 어느 프로퍼티에서 변경되었는지를 알리기 위한 객체
	- [CallerMemberName] 특성 : 어느 프로퍼티 속성에서 PropertyChanged 가 발생했는지 확인 가능하게 해주는 특성 (Attribute)
	
	
#. (C#,WPF동영상)WPF Command패턴, 데이터바인딩DataBinding 개요,실습
	- 이벤트에 대해 이벤트 핸들러를 코드 비하인드에 연결하여 처리했으나, 이 방식은 이벤트 처리 핸들러를 재사용하거나 단위 테스트를 어렵게 한다.
	- 이벤트에 대한 처리 로직 구현 방법
		1) 이벤트 핸들러
		2) Command 클래스 이용 
	- MVVM 에서는 이벤트 핸들러 보다는 Command 를 이용하는 것을 권장
	- 여러 버튼에서 하나의 Command 를 공유할 수 있어 모든 컨트롤마다 Click 이벤트를 만드는 방법 보다 효율적이다.
	- WPF Command 는 ICommand 인터페이스를 구현한다.
		메서드 
			Execute     		: 실제 처리해야할 작업 기술
			CanExecute			: Execute 를 동작하도록 할지 말지를 정의
		이벤트
			CanExecuteChanged : 이벤트를 동작할지 말지
	- 	CommandManager.RequerySuggested 이벤트 발생 방법
		1) CanExecuteChanged 이벤트 발생
		2) CommandManager.InvalidateRequerySuggested() 직접 호출 -> CommandManager.RequerySuggested 이벤트 발생
	- CommandManager.RequerySuggested 이벤트는 CommandManager가 명령 실행에 영향을 줄 수 있는 변경사항이 있다고 생각할 때 마다 발생한다. 발생할때 마다 CanExecute가 호출된다.
	    public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
	
	- CommandManager.RequerySuggested 이벤트 발생 -> CanExecute 호출 (Command 로직 실행) -> CanExecuteChanged 이벤트 발생
	- CanExecuteChanged 이벤트는 CommandManager의 RequerySuggested에 위임되어 모든 종류의 UI상호작용을 통해 변경사항이 호출되는 정확한 알림을 제공한다.
	- RequerySuggested 이벤트의 CommandManager.InvalidateRequerySuggested() 를 호출하여 CommandManager의 RequerySuggested 이벤트를 발생하도록 할 수도 있다.
	- Add 버튼 비활성화 -> TextBox에 Key-In (CanExecuteChanged 이벤트 발생) -> Add 버튼 활성화 -> Add 버튼 클릭 -> TextBox에 데이터 삭제 ((CanExecuteChanged 이벤트 발생)) -> Add 버튼 비활성화
	- Command 패턴의 주체
		클라이언트			: 손님
		Command Object	: 주문서
		Command Invoker	: 웨이터
		Command Receiver : Target, 요리사
	- View => DataContext : ViewModel  (INotifyPropertyChanged 인터페이스 상속한 ObservableObject 클래스를 상속) => Model